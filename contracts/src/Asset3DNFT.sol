// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import {ERC721URIStorage} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import {ERC721Enumerable} from "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import {ERC2981} from "@openzeppelin/contracts/token/common/ERC2981.sol";
import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";
import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";

import {IAsset3DNFT} from "./interfaces/IAsset3DNFT.sol";
import {LibMetadata} from "./libraries/LibMetadata.sol";

/**
 * @title Asset3DNFT
 * @dev NFT contract for 3D assets generated by Meshy AI
 */
contract Asset3DNFT is
    ERC721,
    ERC721URIStorage,
    ERC721Enumerable,
    ERC2981,
    AccessControl,
    Pausable,
    ReentrancyGuard,
    IAsset3DNFT
{
    using LibMetadata for Asset3DMetadata;

    // Roles
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");

    // State variables
    uint256 private _nextTokenId = 1;
    string private _baseTokenUri;

    // Mappings
    mapping(uint256 => Asset3DMetadata) private _assetMetadata;
    mapping(address => uint256[]) private _creatorAssets;
    mapping(string => uint256) private _meshyTaskToToken; // Meshy task ID to token ID

    // Events
    event BaseUriUpdated(string newBaseUri);

    /**
     * @dev Constructor
     * @param name_ Token name
     * @param symbol_ Token symbol
     * @param baseUri_ Base URI for token metadata
     * @param defaultAdmin Default admin address
     */
    constructor(string memory name_, string memory symbol_, string memory baseUri_, address defaultAdmin)
        ERC721(name_, symbol_)
    {
        _baseTokenUri = baseUri_;

        // Grant roles to default admin
        _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);
        _grantRole(MINTER_ROLE, defaultAdmin);
        _grantRole(UPGRADER_ROLE, defaultAdmin);
        _grantRole(PAUSER_ROLE, defaultAdmin);
    }

    /**
     * @dev Mint a new 3D asset NFT
     */
    function mint(address to, Asset3DMetadata calldata metadata)
        external
        onlyRole(MINTER_ROLE)
        whenNotPaused
        nonReentrant
        returns (uint256 tokenId)
    {
        // Validate metadata
        metadata.validateMetadata();

        // Check if Meshy task ID already exists
        require(_meshyTaskToToken[metadata.meshyTaskId] == 0, "Asset3DNFT: Meshy task already minted");

        tokenId = _nextTokenId++;

        // Store metadata (handle dynamic arrays separately)
        Asset3DMetadata storage storedMetadata = _assetMetadata[tokenId];
        storedMetadata.name = metadata.name;
        storedMetadata.description = metadata.description;
        storedMetadata.meshyTaskId = metadata.meshyTaskId;
        storedMetadata.modelUrl = metadata.modelUrl;
        storedMetadata.thumbnailUrl = metadata.thumbnailUrl;
        storedMetadata.videoUrl = metadata.videoUrl;
        storedMetadata.artStyle = metadata.artStyle;
        storedMetadata.mode = metadata.mode;
        storedMetadata.hasTexture = metadata.hasTexture;
        storedMetadata.polycount = metadata.polycount;
        storedMetadata.creator = metadata.creator;
        storedMetadata.royaltyBps = metadata.royaltyBps;
        storedMetadata.createdAt = metadata.createdAt;

        // Handle dynamic array separately
        for (uint256 i = 0; i < metadata.textureUrls.length; i++) {
            storedMetadata.textureUrls.push(metadata.textureUrls[i]);
        }
        _creatorAssets[metadata.creator].push(tokenId);
        _meshyTaskToToken[metadata.meshyTaskId] = tokenId;

        // Set royalty
        _setTokenRoyalty(tokenId, metadata.creator, metadata.royaltyBps);

        // Mint token
        _safeMint(to, tokenId);

        // Set token URI
        string memory uri = LibMetadata.generateTokenUri(tokenId, metadata, _baseTokenUri);
        _setTokenURI(tokenId, uri);

        emit Asset3DMinted(tokenId, metadata.creator, metadata.meshyTaskId, metadata.mode);

        return tokenId;
    }

    /**
     * @dev Batch mint multiple 3D assets
     */
    function batchMint(address to, Asset3DMetadata[] calldata metadataArray)
        external
        onlyRole(MINTER_ROLE)
        whenNotPaused
        nonReentrant
        returns (uint256[] memory tokenIds)
    {
        require(metadataArray.length > 0, "Asset3DNFT: Empty metadata array");
        require(metadataArray.length <= 50, "Asset3DNFT: Batch size too large");

        tokenIds = new uint256[](metadataArray.length);

        for (uint256 i = 0; i < metadataArray.length; i++) {
            Asset3DMetadata calldata metadata = metadataArray[i];

            // Validate metadata
            metadata.validateMetadata();

            // Check if Meshy task ID already exists
            require(_meshyTaskToToken[metadata.meshyTaskId] == 0, "Asset3DNFT: Meshy task already minted");

            uint256 tokenId = _nextTokenId++;
            tokenIds[i] = tokenId;

            // Store metadata (handle dynamic arrays separately)
            Asset3DMetadata storage storedMetadata = _assetMetadata[tokenId];
            storedMetadata.name = metadata.name;
            storedMetadata.description = metadata.description;
            storedMetadata.meshyTaskId = metadata.meshyTaskId;
            storedMetadata.modelUrl = metadata.modelUrl;
            storedMetadata.thumbnailUrl = metadata.thumbnailUrl;
            storedMetadata.videoUrl = metadata.videoUrl;
            storedMetadata.artStyle = metadata.artStyle;
            storedMetadata.mode = metadata.mode;
            storedMetadata.hasTexture = metadata.hasTexture;
            storedMetadata.polycount = metadata.polycount;
            storedMetadata.creator = metadata.creator;
            storedMetadata.royaltyBps = metadata.royaltyBps;
            storedMetadata.createdAt = metadata.createdAt;

            // Handle dynamic array separately
            for (uint256 j = 0; j < metadata.textureUrls.length; j++) {
                storedMetadata.textureUrls.push(metadata.textureUrls[j]);
            }
            _creatorAssets[metadata.creator].push(tokenId);
            _meshyTaskToToken[metadata.meshyTaskId] = tokenId;

            // Set royalty
            _setTokenRoyalty(tokenId, metadata.creator, metadata.royaltyBps);

            // Mint token
            _safeMint(to, tokenId);

            // Set token URI
            string memory uri = LibMetadata.generateTokenUri(tokenId, metadata, _baseTokenUri);
            _setTokenURI(tokenId, uri);

            emit Asset3DMinted(tokenId, metadata.creator, metadata.meshyTaskId, metadata.mode);
        }

        return tokenIds;
    }

    /**
     * @dev Upgrade asset from preview to refine mode
     */
    function upgradeAsset(uint256 tokenId, string calldata newModelUrl, uint256 newPolycount)
        external
        onlyRole(UPGRADER_ROLE)
        whenNotPaused
    {
        require(_ownerOf(tokenId) != address(0), "Asset3DNFT: Token does not exist");

        Asset3DMetadata storage metadata = _assetMetadata[tokenId];
        require(metadata.canUpgradeAsset(), "Asset3DNFT: Asset cannot be upgraded");

        // Update metadata
        metadata.modelUrl = newModelUrl;
        metadata.polycount = newPolycount;
        metadata.mode = 1; // Set to refine mode

        // Update token URI
        string memory uri = LibMetadata.generateTokenUri(tokenId, metadata, _baseTokenUri);
        _setTokenURI(tokenId, uri);

        emit AssetUpgraded(tokenId, newModelUrl, newPolycount);
    }

    /**
     * @dev Update texture URLs for an asset
     */
    function updateTexture(uint256 tokenId, string[] calldata textureUrls)
        external
        onlyRole(UPGRADER_ROLE)
        whenNotPaused
    {
        require(_ownerOf(tokenId) != address(0), "Asset3DNFT: Token does not exist");

        Asset3DMetadata storage metadata = _assetMetadata[tokenId];

        // Clear existing texture URLs
        delete metadata.textureUrls;

        // Add new texture URLs
        for (uint256 i = 0; i < textureUrls.length; i++) {
            metadata.textureUrls.push(textureUrls[i]);
        }

        metadata.hasTexture = textureUrls.length > 0;

        // Update token URI
        string memory uri = LibMetadata.generateTokenUri(tokenId, metadata, _baseTokenUri);
        _setTokenURI(tokenId, uri);

        emit TextureUpdated(tokenId, textureUrls);
    }

    /**
     * @dev Get asset metadata
     */
    function getAssetMetadata(uint256 tokenId) external view returns (Asset3DMetadata memory metadata) {
        require(_ownerOf(tokenId) != address(0), "Asset3DNFT: Token does not exist");
        return _assetMetadata[tokenId];
    }

    /**
     * @dev Get assets by creator
     */
    function getAssetsByCreator(address creator) external view returns (uint256[] memory tokenIds) {
        return _creatorAssets[creator];
    }

    /**
     * @dev Check if asset can be upgraded
     */
    function canUpgrade(uint256 tokenId) external view returns (bool) {
        require(_ownerOf(tokenId) != address(0), "Asset3DNFT: Token does not exist");
        return _assetMetadata[tokenId].canUpgradeAsset();
    }

    /**
     * @dev Get total supply
     */
    function totalSupply() public view override(ERC721Enumerable, IAsset3DNFT) returns (uint256) {
        return super.totalSupply();
    }

    /**
     * @dev Set base URI (admin only)
     */
    function setBaseUri(string calldata newBaseUri) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _baseTokenUri = newBaseUri;
        emit BaseUriUpdated(newBaseUri);
    }

    /**
     * @dev Pause contract (emergency only)
     */
    function pause() external onlyRole(PAUSER_ROLE) {
        _pause();
    }

    /**
     * @dev Unpause contract
     */
    function unpause() external onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    /**
     * @dev Override required by multiple inheritance
     */
    function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    /**
     * @dev Override required by multiple inheritance
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable, ERC721URIStorage, ERC2981, AccessControl, IERC165)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    /**
     * @dev Override required by multiple inheritance
     */
    function _update(address to, uint256 tokenId, address auth)
        internal
        override(ERC721, ERC721Enumerable)
        returns (address)
    {
        return super._update(to, tokenId, auth);
    }

    /**
     * @dev Override required by multiple inheritance
     */
    function _increaseBalance(address account, uint128 value) internal override(ERC721, ERC721Enumerable) {
        super._increaseBalance(account, value);
    }
}
